{
  "version": 3,
  "sources": ["../src/index.js", "../node_modules/regex-utilities/src/index.js", "../node_modules/regex/src/atomic-groups.js", "../node_modules/regex/src/partial.js", "../node_modules/regex/src/utils.js", "../node_modules/regex/src/flag-n.js", "../node_modules/regex/src/flag-x.js", "../node_modules/regex/src/index.js"],
  "sourcesContent": ["import {regex} from 'regex';\nimport {Context, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\nexport function rregex(first, ...values) {\n  const postprocessors = (first?.postprocessors || []).concat(recursion);\n  // Allow binding to other constructors\n  const tag = this instanceof Function ? regex.bind(this) : regex;\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return tag({flags: '', postprocessors})(first, ...values);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !values.length) {\n    return tag({flags: first, postprocessors});\n  // Given an options object\n  } else if ({}.toString.call(first) === '[object Object]' && !values.length) {\n    return tag({...first, postprocessors});\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n\nexport function recursion(pattern) {\n  const groupContentsStartPos = {};\n  let numCharClassesOpen = 0;\n  let match;\n  token.lastIndex = 0;\n  while (match = token.exec(pattern)) {\n    const {0: m, groups: {capturingGroupName, rDepth, gRName, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (capturingGroupName) {\n        groupContentsStartPos[capturingGroupName] = token.lastIndex;\n      // (?R=N)\n      } else if (rDepth) {\n        const maxDepth = +rDepth;\n        assertMaxInBounds(maxDepth);\n        const pre = pattern.slice(0, match.index);\n        const post = pattern.slice(token.lastIndex);\n        assertNoFollowingRecursion(post);\n        return makeRecursive(pre, post, maxDepth);\n      // \\g<name&R=N>\n      } else if (gRName) {\n        const maxDepth = +gRDepth;\n        assertMaxInBounds(maxDepth);\n        const outsideOwnGroupMsg = `Recursion via \\\\g<${gRName}> must be within the referenced group`;\n        // Appears before/outside the referenced group\n        if (!Object.hasOwn(groupContentsStartPos, gRName)) {\n          throw new Error(outsideOwnGroupMsg);\n        }\n        const recursiveGroupContents = getContentsOfGroup(pattern, groupContentsStartPos[gRName]);\n        // Appears after/outside the referenced group\n        if (!hasUnescaped(recursiveGroupContents, gRToken, Context.DEFAULT)) {\n          throw new Error(outsideOwnGroupMsg)\n        }\n        const pre = pattern.slice(groupContentsStartPos[gRName], match.index);\n        const post = recursiveGroupContents.slice(pre.length + m.length);\n        assertNoFollowingRecursion(post);\n        return pattern.slice(0, groupContentsStartPos[gRName]) +\n          makeRecursive(pre, post, maxDepth) +\n          pattern.slice(groupContentsStartPos[gRName] + recursiveGroupContents.length);\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  // No change\n  return pattern;\n}\n\nconst gRToken = String.raw`\\\\g<(?<gRName>[^>&]+)&R=(?<gRDepth>\\d+)>`;\nconst recursiveToken = String.raw`\\(\\?R=(?<rDepth>\\d+)\\)|${gRToken}`;\nconst token = new RegExp(String.raw`\\(\\?<(?![=!])(?<capturingGroupName>[^>]+)>|${recursiveToken}|\\\\?.`, 'gsu');\n\nfunction assertMaxInBounds(max) {\n  if (max < 2 || max > 100) {\n    throw new Error(`Max depth must be between 2 and 100; used ${max}`);\n  }\n}\n\nfunction assertNoFollowingRecursion(remainingPattern) {\n  if (hasUnescaped(remainingPattern, recursiveToken, Context.DEFAULT)) {\n    throw new Error('Cannot use recursion more than once in a pattern');\n  }\n}\n\nfunction getContentsOfGroup(pattern, contentsStartPos) {\n  const token = /(?<groupStart>\\(\\?[:=!<>A-Za-z\\-])|\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = pattern.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(pattern)) {\n    const {0: m, groups: {groupStart}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (groupStart) {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return pattern.slice(contentsStartPos, contentsEndPos);\n}\n\n// Note: Not adjusting numbered backrefs to continue working given the additional capturing groups\n// added (if any). This is mostly a non-issue since the implicit flag n from tag `regex` prevents\n// unnamed capturing groups and numbered backrefs. However, numbered backrefs can appear in\n// interpolated regexes. They could be adjusted with extra effort, by tracking the running number\n// of named/unnamed captures added and rewriting each numbered backref encountered along the way\nfunction makeRecursive(pre, post, maxDepth) {\n  const reps = maxDepth - 1;\n  // Depth 2: 'pre(?:pre(?:)post)post'\n  // Depth 3: 'pre(?:pre(?:pre(?:)post)post)post'\n  return `${pre}${repeatWithDepth(`(?:${pre}`, reps)}(?:)${repeatWithDepth(`${post})`, reps, 'backward')}${post}`;\n}\n\nfunction repeatWithDepth(pattern, reps, direction = 'forward') {\n  const startNum = 2;\n  const depthNum = i => direction === 'backward' ? reps - i + startNum - 1 : i + startNum;\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += replaceUnescaped(\n      pattern,\n      String.raw`\\(\\?<(?<captureName>[^>]+)>|\\\\k<(?<backref>[^>]+)>`,\n      ({groups: {captureName, backref}}) => {\n        const suffix = `_$${captureNum}`;\n        return captureName ? `(?<${captureName}${suffix}>` : `\\\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n", "export const Context = {\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n};\n\n/**\nReplaces patterns only when they're unescaped and in the given context.\nDoesn't skip over complete multicharacter tokens (only `\\` and folowing char) so must be used with\nknowledge of what's safe to do given regex syntax.\nAssumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} pattern\n@param {string} needle Search as a regex pattern, with flags `su`\n@param {string | (match: RegExpExecArray) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [inContext]\n@returns {string} Pattern with replacements\n@example\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~');\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.]~]~`\nreplaceUnescaped(String.raw`.\\.\\\\.\\\\\\.[[\\.].].`, '\\\\.', '~', Context.DEFAULT);\n// -> String.raw`~\\.\\\\~\\\\\\.[[\\.].]~`\n*/\nexport function replaceUnescaped(pattern, needle, replacement, inContext) {\n  const re = new RegExp(String.raw`(?<found>${needle})|\\\\?.`, 'gsu');\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of pattern.matchAll(re)) {\n    const {0: m, groups: {found}} = match;\n    if (found && (!inContext || (inContext === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match);\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRun a callback on the first unescaped version of a pattern in the given context.\nDoesn't skip over complete multicharacter tokens (only `\\` and folowing char) so must be used with\nknowledge of what's safe to do given regex syntax.\nAssumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} pattern\n@param {string} needle Search as a regex pattern, with flags `su`\n@param {(match: RegExpExecArray) => void} [callback]\n@param {'DEFAULT' | 'CHAR_CLASS'} [inContext]\n@returns {boolean} Whether the pattern was found\n*/\nexport function findUnescaped(pattern, needle, callback, inContext) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su')).test(pattern)) {\n    return false;\n  }\n  const re = new RegExp(String.raw`(?<found>${needle})|\\\\?.`, 'gsu');\n  let numCharClassesOpen = 0;\n  for (const match of pattern.matchAll(re)) {\n    const {0: m, groups: {found}} = match;\n    if (found && (!inContext || (inContext === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (callback) {\n        callback(match);\n      }\n      return true;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n  }\n  return false;\n}\n\n/**\nCheck whether an unescaped version of a pattern appears in the given context.\nDoesn't skip over complete multicharacter tokens (only `\\` and folowing char) so must be used with\nknowledge of what's safe to do given regex syntax.\nAssumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} pattern\n@param {string} needle Search as a regex pattern, with flags `su`\n@param {'DEFAULT' | 'CHAR_CLASS'} [inContext]\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(pattern, needle, inContext) {\n  return findUnescaped(pattern, needle, null, inContext);\n}\n", "import {Context, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\nexport function transformAtomicGroups(pattern) {\n  if (!hasUnescaped(pattern, String.raw`\\(\\?>`, Context.DEFAULT)) {\n    return pattern;\n  }\n  const token = new RegExp(String.raw`(?<noncapturingStart>\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]))|(?<capturingStart>\\((?:\\?<[^>]+>)?)|(?<backrefNum>\\\\[1-9]\\d*)|\\\\?.`, 'gsu');\n  const aGDelimLen = '(?>'.length;\n  let hasProcessedAG;\n  let capturingGroupCount = 0;\n  let aGCount = 0;\n  let aGPos = NaN;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    token.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + aGDelimLen;\n    while (match = token.exec(pattern)) {\n      const {0: m, index: pos, groups: {backrefNum, capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n        if (m === '(?>' && !inAG) {\n          aGPos = pos;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          }\n          capturingGroupCount++;\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            aGCount++;\n            // Replace `pattern` and start over from the opening position of the atomic group, in\n            // case the processed group contains additional atomic groups\n            pattern = `${pattern.slice(0, aGPos)}(?:(?=(${pattern.slice(aGPos + aGDelimLen, pos)}))\\\\k<${aGCount + capturingGroupCount}>)${pattern.slice(pos + 1)}`;\n            hasProcessedAG = true;\n            // Subtract the capturing group we just added as part of emulating an atomic group\n            capturingGroupCount--;\n            break;\n          }\n          numGroupsOpenInAG--;\n        } else if (backrefNum) {\n          // Could allow this with extra effort (adjusting both the backreferences found and those\n          // used to emulate atomic groups) but it's probably not worth it. To trigger this, the\n          // regex must contain both an atomic group and an interpolated RegExp instance with a\n          // numbered backreference\n          throw new Error(`Invalid decimal escape \"${m}\" in interpolated regex; cannot be used with atomic group`);\n        }\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  } while (hasProcessedAG);\n  // Replace the `\\k<\u2026>` added as a shield from the check for invalid numbered backreferences\n  pattern = replaceUnescaped(\n    pattern,\n    String.raw`\\\\k<(?<backrefNum>\\d+)>`,\n    ({groups: {backrefNum}}) => `\\\\${backrefNum}`,\n    Context.DEFAULT\n  );\n  return pattern;\n}\n", "export class PartialPattern {\n  #value;\n  constructor(pattern) {\n    this.#value = pattern;\n  }\n  toString() {\n    return String(this.#value);\n  }\n}\n\n/**\nCan be called in two ways:\n1. `partial(value)` - For strings or values coerced to strings\n2. `` partial`\u2026` `` - Shorthand for ``partial(String.raw`\u2026`)``\n@param {any} first\n@param {...any} [values] Values to fill the template holes.\n@returns {PartialPattern}\n*/\nexport function partial(first, ...values) {\n  if (Array.isArray(first?.raw)) {\n    return new PartialPattern(\n      // Intersperse template raw strings and values\n      first.raw.flatMap((raw, i) => i < first.raw.length - 1 ? [raw, values[i]] : raw).join('')\n    );\n  } else if (!values.length) {\n    return new PartialPattern(first ?? '');\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n}\n", "import {Context, replaceUnescaped} from 'regex-utilities';\nimport {PartialPattern, partial} from './partial.js';\n\nexport const RegexContext = {\n  ...Context,\n  GROUP_NAME: 'GROUP_NAME',\n  ENCLOSED_TOKEN: 'ENCLOSED_TOKEN',\n  INTERVAL_QUANTIFIER: 'INTERVAL_QUANTIFIER',\n  INVALID_INCOMPLETE_TOKEN: 'INVALID_INCOMPLETE_TOKEN',\n};\n\nexport const CharClassContext = {\n  DEFAULT: 'CC_DEFAULT',\n  RANGE: 'CC_RANGE',\n  ENCLOSED_TOKEN: 'CC_ENCLOSED_TOKEN',\n  Q_TOKEN: 'CC_Q_TOKEN',\n  INVALID_INCOMPLETE_TOKEN: 'CC_INVALID_INCOMPLETE_TOKEN',\n};\n\nexport const patternModsOn = (() => {\n  let supported = true;\n  try {\n    new RegExp('(?i-ms:)');\n  } catch (e) {\n    supported = false;\n  }\n  return supported;\n})();\n\nconst doublePunctuatorChars = '&!#$%*+,.:;<=>?@^`~';\n\n/**\n@param {string} str\n@param {'DEFAULT' | 'CHAR_CLASS'} regexContext\n@returns {string}\n*/\nexport function escapeV(str, regexContext) {\n  if (regexContext === RegexContext.CHAR_CLASS) {\n    // Escape all double punctuators (including ^, which is special on its own in the first\n    // position) in case they're bordered by the same character in or outside of the escaped string\n    return str.replace(new RegExp(String.raw`[()\\[\\]{}|\\\\/\\-${doublePunctuatorChars}]`, 'g'), '\\\\$&');\n  }\n  return str.replace(/[()\\[\\]{}|\\\\^$*+?.]/g, '\\\\$&');\n}\n\n// Sandbox without escaping by repeating the character and escaping only the first one. The second\n// one is so that, if followed by the same symbol, the resulting double punctuator will still throw\n// as expected. Details:\n// - Only need to check the first position because, if it's part of an implicit union,\n//   interpolation handling will wrap it in nested `[\u2026]`.\n// - Can't just wrap in nested `[\u2026]` here, since the value might be used in a range.\n// - Can't add a second unescaped symbol if a lone symbol is the entire string because it might be\n//   followed by the same unescaped symbol outside an interpolation, and since it won't be wrapped,\n//   the second symbol wouldn't be sandboxed from the one following it.\nexport function sandboxLoneDoublePunctuatorChar(str) {\n  return str.replace(new RegExp(String.raw`^([${doublePunctuatorChars}])(?!\\1)`), (m, _, pos) => {\n    return `\\\\${m}${pos + 1 === str.length ? '' : m}`;\n  });\n}\n\n// Sandbox `^` if relevant, done so it can't change the meaning of the surrounding character class\n// if we happen to be at the first position. See `sandboxLoneDoublePunctuatorChar` for more details\nexport function sandboxLoneCharClassCaret(str) {\n  return str.replace(/^\\^/, '\\\\^^');\n}\n\n// regex`[\\0${0}]` and regex`[${partial`\\0`}0]` can't be guarded against via nested `[\u2026]`\n// sandboxing in character classes if the interpolated value doesn't contain union (since it might\n// be placed on a range boundary). So escape \\0 in character classes as \\u{0}\nexport function sandboxUnsafeNulls(str, inContext) {\n  return replaceUnescaped(str, String.raw`\\\\0(?!\\d)`, '\\\\u{0}', inContext);\n}\n\n// No special handling for escaped versions of the characters\nfunction getUnbalancedChar(pattern, leftChar, rightChar) {\n  let numOpen = 0;\n  for (const [m] of pattern.matchAll(new RegExp(`[${escapeV(leftChar + rightChar)}]`, 'g'))) {\n    numOpen += m === leftChar ? 1 : -1;\n    if (numOpen < 0) {\n      return rightChar;\n    }\n  }\n  if (numOpen > 0) {\n    return leftChar;\n  }\n  return '';\n}\n\n// Look for characters that would change the meaning of subsequent tokens outside an interpolated value\nexport function getBreakoutChar(pattern, regexContext, charClassContext) {\n  const escapesRemoved = pattern.replace(/\\\\./gsu, '');\n  // Trailing unescaped `\\`. Checking `escapesRemoved.includes('\\\\')` would also work\n  if (escapesRemoved.at(-1) === '\\\\') {\n    return '\\\\';\n  }\n  if (regexContext === RegexContext.DEFAULT) {\n    // Unbalanced `[` or `]` are also errors but don't breakout; they're caught by the wrapper\n    return getUnbalancedChar(escapesRemoved, '(', ')');\n  } else if (\n    regexContext === RegexContext.CHAR_CLASS &&\n    !(charClassContext === CharClassContext.ENCLOSED_TOKEN || charClassContext === CharClassContext.Q_TOKEN)\n  ) {\n    return getUnbalancedChar(escapesRemoved, '[', ']');\n  } else if (\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    charClassContext === CharClassContext.ENCLOSED_TOKEN ||\n    charClassContext === CharClassContext.Q_TOKEN\n  ) {\n    if (escapesRemoved.includes('}')) {\n      return '}';\n    }\n  } else if (regexContext === RegexContext.GROUP_NAME) {\n    if (escapesRemoved.includes('>')) {\n      return '>';\n    }\n  }\n  return '';\n}\n\n// To support flag x handling (where this regex is reused as a tokenizer, which isn't really its\n// purpose in `getEndContextForIncompletePattern`), the following tokens are added which would\n// otherwise not need special handling here:\n// - Partial token versions of `\\\\[cux]`. Without serving dual purpose for flag x, `incompleteT`\n//   would only *need* to know about trailing unescaped `\\\\`.\n// - Complete token versions of `\\\\[cux0]`.\n// - Negated character class opener `[^`.\n// - Group openings, so they can be stepped past (also relied on by flag n).\n// - Double-punctuators.\n// To support flag n, complete backreference numbers were also added so they can be shown in error\n// messages. To support atomic groups, `(?>` was added\nexport const contextToken = new RegExp(String.raw`\n  (?<groupN> \\(\\?< (?! [=!] ) | \\\\k< )\n| (?<enclosedT> \\\\[pPu]\\{ )\n| (?<qT> \\\\q\\{ )\n| (?<intervalQ> \\{ )\n| (?<incompleteT> \\\\ (?:\n    $\n  | c (?! [A-Za-z] )\n  | u (?! [A-Fa-f\\d]{4} ) [A-Fa-f\\d]{0,3}\n  | x (?! [A-Fa-f\\d]{2} ) [A-Fa-f\\d]?\n  )\n)\n| \\\\ (?:\n    c [A-Za-z]\n  | u [A-Fa-f\\d]{4}\n  | x [A-Fa-f\\d]{2}\n  | 0 \\d+\n)\n| \\[\\^\n| \\(\\? [:=!<>A-Za-z\\-]\n| (?<dp> [${doublePunctuatorChars}] ) \\k<dp>\n| \\\\[1-9]\\d*\n| --\n| \\\\? .\n`.replace(/\\s+/g, ''), 'gsu');\n\n// Accepts and returns its full state so it doesn't have to reprocess pattern parts that it's\n// already seen. Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function getEndContextForIncompletePattern(partialPattern, {\n  regexContext = RegexContext.DEFAULT,\n  charClassContext = CharClassContext.DEFAULT,\n  charClassDepth = 0,\n  lastPos = 0,\n}) {\n  contextToken.lastIndex = lastPos;\n  let match;\n  while (match = contextToken.exec(partialPattern)) {\n    const {0: m, groups: {groupN, enclosedT, qT, intervalQ, incompleteT}} = match;\n    if (m === '[' || m === '[^') {\n      charClassDepth++;\n      regexContext = RegexContext.CHAR_CLASS;\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (m === ']' && regexContext === RegexContext.CHAR_CLASS) {\n      if (charClassDepth) {\n        charClassDepth--;\n      }\n      if (!charClassDepth) {\n        regexContext = RegexContext.DEFAULT;\n      }\n      // Reset for accuracy, but it will end up being an error if there is an unclosed context\n      // (ex: `\\q{\u2026` without closing `}`) in the character class\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (regexContext === RegexContext.CHAR_CLASS) {\n      if (incompleteT) {\n        charClassContext = CharClassContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (m === '-') {\n        charClassContext = CharClassContext.RANGE;\n      } else if (enclosedT) {\n        charClassContext = CharClassContext.ENCLOSED_TOKEN;\n      } else if (qT) {\n        charClassContext = CharClassContext.Q_TOKEN;\n      } else if (\n        (m === '}' && (charClassContext === CharClassContext.ENCLOSED_TOKEN || charClassContext === CharClassContext.Q_TOKEN)) ||\n        // Don't want to continue in these contexts if we've advanced another token\n        charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN ||\n        charClassContext === CharClassContext.RANGE\n      ) {\n        charClassContext = CharClassContext.DEFAULT;\n      }\n    } else {\n      if (incompleteT) {\n        regexContext = RegexContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (groupN) {\n        regexContext = RegexContext.GROUP_NAME;\n      } else if (enclosedT) {\n        regexContext = RegexContext.ENCLOSED_TOKEN;\n      } else if (intervalQ) {\n        regexContext = RegexContext.INTERVAL_QUANTIFIER;\n      } else if (\n        (m === '>' && regexContext === RegexContext.GROUP_NAME) ||\n        (m === '}' && (regexContext === RegexContext.ENCLOSED_TOKEN || regexContext === RegexContext.INTERVAL_QUANTIFIER)) ||\n        // Don't want to continue in this context if we've advanced another token\n        regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN\n       ) {\n        regexContext = RegexContext.DEFAULT;\n      }\n    }\n  }\n  return {\n    regexContext,\n    charClassContext,\n    charClassDepth,\n    lastPos: partialPattern.length,\n  };\n}\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function countCaptures(pattern) {\n  const re = /(?<capture>\\((?:(?!\\?)|\\?<[^>]+>))|\\\\?./gsu;\n  // Don't worry about tracking if we're in a character class or other invalid context for an\n  // unescaped `(`, because (given flag v) the unescaped `(` is invalid anyway. However, that means\n  // backrefs in subsequent interpolated regexes might be adjusted using an incorrect count, which\n  // is displayed in the error message about the overall regex being invalid\n  return Array.from(pattern.matchAll(re)).filter(m => m.groups.capture).length;\n}\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function adjustNumberedBackrefs(pattern, precedingCaptures) {\n  // Note: Because this doesn't track whether matches are in a character class, it renumbers\n  // regardless. That's not a significant issue because the regex would be invalid even without\n  // renumbering (given flag v), but the error is more confusing when e.g. an invalid `[\\1]` is\n  // shown as `[\\2]`\n  return pattern.replace(\n    /\\\\([1-9]\\d*)|\\\\?./gsu,\n    (m, b1) => b1 ? '\\\\' + (Number(b1) + precedingCaptures) : m\n  );\n}\n\nconst propertiesOfStringsNames = [\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n  'RGI_Emoji',\n].join('|');\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nexport function containsCharClassUnion(charClassPattern) {\n  // Return `true` if contains:\n  // - Lowercase `\\p` and name is a property of strings (case sensitive).\n  // - `\\q`.\n  // - Two single-char-matching tokens in sequence.\n  // - One single-char-matching token followed immediately by unescaped `[`.\n  // - One single-char-matching token preceded immediately by unescaped `]`.\n  // Else, `false`.\n  // Ranges with `-` create a single token.\n  // Subtraction and intersection with `--` and `&&` create a single token.\n  // Supports any number of nested classes\n  const re = new RegExp(String.raw`\n\\\\ (?:\n    c [A-Za-z]\n  | p \\{ (?<pPropOfStr> ${propertiesOfStringsNames} ) \\}\n  | [pP] \\{ [^\\}]+ \\}\n  | (?<qPropOfStr> q )\n  | u (?: [A-Fa-f\\d]{4} | \\{ [A-Fa-f\\d]+ \\} )\n  | x [A-Fa-f\\d]{2}\n  | .\n)\n| --\n| &&\n| .\n  `.replace(/\\s+/g, ''), 'gsu');\n  let hasFirst = false;\n  let lastM;\n  for (const {0: m, groups} of charClassPattern.matchAll(re)) {\n    if (groups.pPropOfStr || groups.qPropOfStr) {\n      return true;\n    }\n    if (m === '[' && hasFirst) {\n      return true;\n    }\n    if (['-', '--', '&&'].includes(m)) {\n      hasFirst = false;\n    } else if (!['[', ']'].includes(m)) {\n      if (hasFirst || lastM === ']') {\n        return true;\n      }\n      hasFirst = true;\n    }\n    lastM = m;\n  }\n  return false;\n}\n\n/**\nThe template's `raw` array is processed, along with (only) values that are instanceof `PartialPattern`.\n@param {TemplateStringsArray} template\n@param {any[]} values\n@param {(value, runningContext) => {transformed: string; runningContext: Object}} processor\n@returns {{template: TemplateStringsArray; values: any[]}}\n*/\nexport function transformTemplateAndValues(template, values, processor) {\n  let newTemplate = {raw: []};\n  let newValues = [];\n  let runningContext = {};\n  template.raw.forEach((raw, i) => {\n    const result = processor(raw, {...runningContext, lastPos: 0});\n    newTemplate.raw.push(result.transformed);\n    runningContext = result.runningContext;\n    if (i < template.raw.length - 1) {\n      const value = values[i];\n      if (value instanceof PartialPattern) {\n        const result = processor(value, {...runningContext, lastPos: 0});\n        newValues.push(partial(result.transformed));\n        runningContext = result.runningContext;\n      } else {\n        newValues.push(value);\n      }\n    }\n  });\n  return {\n    template: newTemplate,\n    values: newValues,\n  };\n}\n", "import {RegexContext, contextToken, getEndContextForIncompletePattern} from './utils.js';\n\n// Applied to the outer regex and interpolated partials, but not interpolated regexes or strings\nexport function flagNProcessor(value, runningContext) {\n  value = String(value);\n  let pattern = '';\n  let transformed = '';\n  for (const [m] of value.matchAll(contextToken)) {\n    pattern += m;\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext} = runningContext;\n    if (regexContext === RegexContext.DEFAULT) {\n      if (m === '(') {\n        transformed += '(?:';\n      } else if (/^\\\\[1-9]/.test(m)) {\n        throw new Error(`Invalid decimal escape \"${m}\" with implicit flag n; replace with named backreference`);\n      } else {\n        transformed += m;\n      }\n    } else {\n      transformed += m;\n    }\n  }\n  return {\n    transformed,\n    runningContext,\n  };\n}\n", "import {Context, replaceUnescaped} from 'regex-utilities';\nimport {CharClassContext, RegexContext, contextToken, getEndContextForIncompletePattern, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls} from './utils.js';\n\nconst ws = /^\\s$/;\nconst escapedWsOrHash = /^\\\\[\\s#]$/;\nconst charClassWs = /^[ \\t]$/;\nconst escapedCharClassWs = /^\\\\[ \\t]$/;\n\n// Applied to the outer regex and interpolated partials, but not interpolated regexes or strings\nexport function flagXProcessor(value, runningContext) {\n  value = String(value);\n  let ignoringWs = false;\n  let ignoringCharClassWs = false;\n  let ignoringComment = false;\n  let pattern = '';\n  let transformed = '';\n  let lastSignificantToken = '';\n  let lastSignificantCharClassContext = '';\n  let divNeeded = false;\n  const update = (str, {prefix = true, postfix = false} = {}) => {\n    str = (divNeeded && prefix ? '(?:)' : '') + str + (postfix ? '(?:)' : '');\n    divNeeded = false;\n    return str;\n  };\n  for (const [m] of value.matchAll(contextToken)) {\n    if (ignoringComment) {\n      if (m === '\\n') {\n        ignoringComment = false;\n        divNeeded = true;\n      }\n      continue;\n    }\n    if (ignoringWs) {\n      if (ws.test(m)) {\n        continue;\n      }\n      ignoringWs = false;\n      divNeeded = true;\n    } else if (ignoringCharClassWs) {\n      if (charClassWs.test(m)) {\n        continue;\n      }\n      ignoringCharClassWs = false;\n    }\n\n    pattern += m;\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (m === '-' && regexContext === RegexContext.CHAR_CLASS && lastSignificantCharClassContext === CharClassContext.RANGE) {\n      // Need to handle this here since the main regex-parsing code would think the hyphen forms\n      // part of a subtraction operator since we've removed preceding ws\n      throw new Error('Invalid unescaped hyphen as the end value for a range');\n    }\n    if ((regexContext === RegexContext.DEFAULT && /^[?*+]\\??$/.test(m)) || (regexContext === RegexContext.INTERVAL_QUANTIFIER && m === '{')) {\n      // Skip the separator prefix and connect the quantifier to the previous token. Add a\n      // separator postfix if `m` is `?` to sandbox it from follwing tokens since `?` can be a\n      // group-type marker. Ex: `( ?:)` becomes `(?(?:):)` and throws. The loop we're in matches\n      // valid group openings in one step, so we won't arrive here if matching e.g. `(?:`. Flag n\n      // precludes the need for the postfix since bare `(` is converted to `(?:`, but flag n can be\n      // turned off\n      transformed += update(m, {prefix: false, postfix: lastSignificantToken === '('});\n    } else if (regexContext === RegexContext.DEFAULT) {\n      if (ws.test(m)) {\n        ignoringWs = true;\n      } else if (m.startsWith('#')) {\n        ignoringComment = true;\n      } else if (escapedWsOrHash.test(m)) {\n        transformed += update(m[1], {prefix: false});\n      } else {\n        transformed += update(m);\n      }\n    } else if (regexContext === RegexContext.CHAR_CLASS && m !== '[' && m !== '[^') {\n      if (\n        charClassWs.test(m) &&\n        ( charClassContext === CharClassContext.DEFAULT ||\n          charClassContext === CharClassContext.RANGE ||\n          charClassContext === CharClassContext.Q_TOKEN\n        )\n      ) {\n        ignoringCharClassWs = true;\n      } else if (charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n        // Need to handle this here since the main regex-parsing code wouldn't know where the token\n        // ends if we removed ws after it that was followed by something that completes the token\n        throw new Error(`Invalid incomplete token in character class: \"${m}\"`);\n      } else if (\n        escapedCharClassWs.test(m) &&\n        (charClassContext === CharClassContext.DEFAULT || charClassContext === CharClassContext.Q_TOKEN)\n      ) {\n          transformed += update(m[1], {prefix: false});\n      } else if (charClassContext === CharClassContext.DEFAULT) {\n          transformed += update(sandboxLoneDoublePunctuatorChar(sandboxUnsafeNulls(m)));\n      } else {\n        transformed += update(m);\n      }\n    } else {\n      transformed += update(m);\n    }\n    if (!(ignoringWs || ignoringCharClassWs || ignoringComment)) {\n      lastSignificantToken = m;\n      lastSignificantCharClassContext = charClassContext;\n    }\n  }\n  return {\n    transformed,\n    runningContext,\n  };\n}\n\n// Remove `(?:)` separators (most likely added by flag x) in cases where it's safe to do so\nexport function rakeSeparators(pattern) {\n  const sep = String.raw`\\(\\?:\\)`;\n  // No need for repeated separators\n  pattern = replaceUnescaped(pattern, `${sep}(?:${sep})+`, '(?:)', Context.DEFAULT);\n  // No need for separators at:\n  // - The beginning, if not followed by a quantifier.\n  // - The end.\n  // - Before one of `()|$\\`.\n  // - After one of `()|>^` or the opening of a non-capturing group or lookaround.\n  pattern = replaceUnescaped(\n    pattern,\n    String.raw`^${sep}(?![?*+{])|${sep}$|${sep}(?=[()|$\\\\])|(?<=[()|>^]|\\(\\?(?:[:=!]|<[=!]))${sep}`,\n    '',\n    Context.DEFAULT\n  );\n  return pattern;\n}\n", "//! regex 1.1.1; Steven Levithan; MIT License\n\nimport {Context, replaceUnescaped} from 'regex-utilities';\nimport {transformAtomicGroups} from './atomic-groups.js';\nimport {flagNProcessor} from './flag-n.js';\nimport {flagXProcessor, rakeSeparators} from './flag-x.js';\nimport {PartialPattern, partial} from './partial.js';\nimport {CharClassContext, RegexContext, adjustNumberedBackrefs, containsCharClassUnion, countCaptures, escapeV, getBreakoutChar, getEndContextForIncompletePattern, patternModsOn, sandboxLoneCharClassCaret, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls, transformTemplateAndValues} from './utils.js';\n\n/**\n@typedef {Object} RegexTagOptions\n@prop {string} [flags]\n@prop {Array<Function>} [postprocessors]\n@prop {boolean} [__flagN]\n@prop {boolean} [__flagX]\n@prop {boolean} [__rake]\n*/\n\n/**\nTemplate tag for constructing a UnicodeSets-mode RegExp with advanced features and context-aware\ninterpolation of regexes, escaped strings, and partial patterns.\n\nCan be called in multiple ways:\n1. `` regex`\u2026` `` - Regex pattern as a raw string.\n2. `` regex('gis')`\u2026` `` - To specify flags.\n3. `` regex({flags: 'gis'})`\u2026` `` - With options.\n4. `` regex.bind(RegExpSubclass)`\u2026` `` - With a `this` that specifies a different constructor.\n\n@type {{\n  (flags?: string) => (TemplateStringsArray, ...values) => RegExp;\n  (options: RegexTagOptions) => (TemplateStringsArray, ...values) => RegExp;\n  (template: TemplateStringsArray, ...values) => RegExp;\n}}\n*/\nconst regex = function(first, ...values) {\n  // Allow binding to other constructors\n  const constructor = this instanceof Function ? this : RegExp;\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return fromTemplate(constructor, {flags: ''}, first, ...values);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !values.length) {\n    return fromTemplate.bind(null, constructor, {flags: first});\n  // Given an options object\n  } else if ({}.toString.call(first) === '[object Object]' && !values.length) {\n    return fromTemplate.bind(null, constructor, first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...values])}`);\n};\n\n/**\nMakes a UnicodeSets-mode RegExp from a template and values to fill the template holes.\n@param {RegExpConstructor | (pattern: string, flags: string) => RegExp} constructor\n@param {RegexTagOptions} options\n@param {TemplateStringsArray} template\n@param {...any} values\n@returns {RegExp}\n*/\nfunction fromTemplate(constructor, options, template, ...values) {\n  const {\n    flags = '',\n    postprocessors = [],\n    __flagN = true,\n    __flagX = true,\n    __rake = true,\n  } = options;\n  if (/[vu]/.test(flags)) {\n    throw new Error('Flags v/u cannot be explicitly added since v is always enabled');\n  }\n\n  // Implicit flag x is handled first because otherwise some regex syntax (if unescaped) within\n  // comments could cause problems when parsing\n  if (__flagX) {\n    ({template, values} = transformTemplateAndValues(template, values, flagXProcessor));\n  }\n  if (__flagN) {\n    ({template, values} = transformTemplateAndValues(template, values, flagNProcessor));\n  }\n\n  let precedingCaptures = 0;\n  let pattern = '';\n  let runningContext = {};\n  // Intersperse template raw strings and values\n  template.raw.forEach((raw, i) => {\n    const wrapEscapedStr = template.raw[i] || template.raw[i + 1];\n    // Even with flag n enabled, we might have named captures\n    precedingCaptures += countCaptures(raw);\n    // Sandbox `\\0` in character classes. Not needed outside character classes because in other\n    // cases a following interpolated value would always be atomized\n    pattern += sandboxUnsafeNulls(raw, Context.CHAR_CLASS);\n    runningContext = getEndContextForIncompletePattern(pattern, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (i < template.raw.length - 1) {\n      const interpolated = interpolate(values[i], flags, regexContext, charClassContext, wrapEscapedStr, precedingCaptures);\n      precedingCaptures += interpolated.capturesAdded || 0;\n      pattern += interpolated.value;\n    }\n  });\n\n  const postp = [transformAtomicGroups, ...postprocessors];\n  if (__rake) {\n    postp.push(rakeSeparators);\n  }\n  for (const p of postp) {\n    pattern = p(pattern);\n  }\n  return new constructor(pattern, `v${flags}`);\n}\n\nfunction interpolate(value, flags, regexContext, charClassContext, wrapEscapedStr, precedingCaptures) {\n  if (value instanceof RegExp && regexContext !== RegexContext.DEFAULT) {\n    throw new Error('Cannot interpolate a RegExp at this position because the syntax context does not match');\n  }\n  if (regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN || charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n    // Throw in all cases, but only *need* to handle a preceding unescaped backslash (which would\n    // break sandboxing) since other errors would be handled by the invalid generated regex syntax\n    throw new Error('Interpolation preceded by invalid incomplete token');\n  }\n  const isPartial = value instanceof PartialPattern;\n  let escapedValue;\n  if (!(value instanceof RegExp)) {\n    value = String(value);\n    if (!isPartial) {\n      escapedValue = escapeV(value, regexContext);\n    }\n    // Check within escaped values (not just partials) since possible breakout char > isn't escaped\n    const breakoutChar = getBreakoutChar(escapedValue || value, regexContext, charClassContext);\n    if (breakoutChar) {\n      throw new Error(`Unescaped stray \"${breakoutChar}\" in the interpolated value would have side effects outside it`);\n    }\n  }\n\n  if (\n    regexContext === RegexContext.ENCLOSED_TOKEN ||\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    regexContext === RegexContext.GROUP_NAME ||\n    charClassContext === CharClassContext.ENCLOSED_TOKEN ||\n    charClassContext === CharClassContext.Q_TOKEN\n  ) {\n    return {value: isPartial ? value : escapedValue};\n  } else if (regexContext === RegexContext.CHAR_CLASS) {\n    if (isPartial) {\n      const boundaryOperatorsRemoved = replaceUnescaped(value, '^-|^&&|-$|&&$', '');\n      if (boundaryOperatorsRemoved !== value) {\n        // Sandboxing so we don't change the chars outside the partial into being part of an\n        // operation they didn't initiate. Same as starting a partial with a quantifier\n        throw new Error('In character classes, a partial cannot use a range/set operator at its boundary; move the operation into the partial or the operator outside of it');\n      }\n      const sandboxedValue = sandboxLoneCharClassCaret(sandboxLoneDoublePunctuatorChar(value));\n      // Atomize via nested character class `[\u2026]` if it contains implicit or explicit union (check\n      // the unadjusted value)\n      return {value: containsCharClassUnion(value) ? `[${sandboxedValue}]` : sandboxUnsafeNulls(sandboxedValue)};\n    }\n    // Atomize via nested character class `[\u2026]` if more than one node\n    return {value: containsCharClassUnion(escapedValue) ? `[${escapedValue}]` : escapedValue};\n  }\n  // `RegexContext.DEFAULT`\n  if (value instanceof RegExp) {\n    const transformed = transformForLocalFlags(value, flags);\n    const backrefsAdjusted = adjustNumberedBackrefs(transformed.value, precedingCaptures);\n    // Sandbox and atomize; if we used a pattern modifier it has the same effect\n    return {\n      value: transformed.usedModifier ? backrefsAdjusted : `(?:${backrefsAdjusted})`,\n      capturesAdded: countCaptures(value.source),\n    };\n  }\n  if (isPartial) {\n    // Sandbox and atomize\n    return {value: `(?:${value})`};\n  }\n  // Sandbox and atomize\n  return {value: wrapEscapedStr ? `(?:${escapedValue})` : escapedValue};\n}\n\n/**\n@param {RegExp} re\n@param {string} outerFlags\n@returns {Object}\n*/\nfunction transformForLocalFlags(re, outerFlags) {\n  const modFlagsObj = {\n    i: null,\n    m: null,\n    s: null,\n  };\n  const newlines = '\\\\n\\\\r\\\\u2028\\\\u2029';\n  let value = re.source;\n\n  if (re.ignoreCase !== outerFlags.includes('i')) {\n    if (patternModsOn) {\n      modFlagsObj.i = re.ignoreCase;\n    } else {\n      throw new Error('Pattern modifiers not supported, so the value of flag i on the interpolated RegExp must match the outer regex');\n    }\n  }\n  if (re.dotAll !== outerFlags.includes('s')) {\n    if (patternModsOn) {\n      modFlagsObj.s = re.dotAll;\n    } else {\n      value = replaceUnescaped(value, '\\\\.', (re.dotAll ? '[^]' : `[^${newlines}]`), Context.DEFAULT);\n    }\n  }\n  if (re.multiline !== outerFlags.includes('m')) {\n    if (patternModsOn) {\n      modFlagsObj.m = re.multiline;\n    } else {\n      value = replaceUnescaped(value, '\\\\^', (re.multiline ? `(?<=^|[${newlines}])` : '(?<![^])'), Context.DEFAULT);\n      value = replaceUnescaped(value, '\\\\$', (re.multiline ? `(?=$|[${newlines}])` : '(?![^])'), Context.DEFAULT);\n    }\n  }\n\n  if (patternModsOn) {\n    const keys = Object.keys(modFlagsObj);\n    let modifier = keys.filter(k => modFlagsObj[k] === true).join('');\n    const modOff = keys.filter(k => modFlagsObj[k] === false).join('');\n    if (modOff) {\n      modifier += `-${modOff}`;\n    }\n    if (modifier) {\n      return {\n        value: `(?${modifier}:${value})`,\n        usedModifier: true,\n      };\n    }\n  }\n  return {value};\n}\n\n// Alias for backcompat with v1.0.0; might be removed in v2\nconst make = regex;\n\nexport {make, partial, regex};\n\n// The default export is deprecated and might be removed in v2\nexport default {make, partial, regex};\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "recursion", "rregex", "Context", "replaceUnescaped", "pattern", "needle", "replacement", "inContext", "re", "numCharClassesOpen", "result", "match", "m", "found", "findUnescaped", "callback", "hasUnescaped", "transformAtomicGroups", "pattern", "hasUnescaped", "Context", "token", "aGDelimLen", "hasProcessedAG", "capturingGroupCount", "aGCount", "aGPos", "numCharClassesOpen", "numGroupsOpenInAG", "inAG", "match", "m", "pos", "backrefNum", "capturingStart", "noncapturingStart", "replaceUnescaped", "PartialPattern", "#value", "pattern", "partial", "first", "values", "raw", "i", "RegexContext", "Context", "CharClassContext", "patternModsOn", "supported", "doublePunctuatorChars", "escapeV", "str", "regexContext", "sandboxLoneDoublePunctuatorChar", "m", "_", "pos", "sandboxLoneCharClassCaret", "sandboxUnsafeNulls", "inContext", "replaceUnescaped", "getUnbalancedChar", "pattern", "leftChar", "rightChar", "numOpen", "getBreakoutChar", "charClassContext", "escapesRemoved", "contextToken", "getEndContextForIncompletePattern", "partialPattern", "charClassDepth", "lastPos", "match", "groupN", "enclosedT", "qT", "intervalQ", "incompleteT", "countCaptures", "re", "adjustNumberedBackrefs", "precedingCaptures", "b1", "propertiesOfStringsNames", "containsCharClassUnion", "charClassPattern", "hasFirst", "lastM", "groups", "transformTemplateAndValues", "template", "values", "processor", "newTemplate", "newValues", "runningContext", "raw", "result", "value", "PartialPattern", "partial", "flagNProcessor", "value", "runningContext", "pattern", "transformed", "m", "contextToken", "getEndContextForIncompletePattern", "regexContext", "RegexContext", "ws", "escapedWsOrHash", "charClassWs", "escapedCharClassWs", "flagXProcessor", "value", "runningContext", "ignoringWs", "ignoringCharClassWs", "ignoringComment", "pattern", "transformed", "lastSignificantToken", "lastSignificantCharClassContext", "divNeeded", "update", "str", "prefix", "postfix", "m", "contextToken", "getEndContextForIncompletePattern", "regexContext", "charClassContext", "RegexContext", "CharClassContext", "sandboxLoneDoublePunctuatorChar", "sandboxUnsafeNulls", "rakeSeparators", "sep", "replaceUnescaped", "Context", "regex", "first", "values", "constructor", "fromTemplate", "options", "template", "flags", "postprocessors", "__flagN", "__flagX", "__rake", "transformTemplateAndValues", "flagXProcessor", "flagNProcessor", "precedingCaptures", "pattern", "runningContext", "raw", "i", "wrapEscapedStr", "countCaptures", "sandboxUnsafeNulls", "Context", "getEndContextForIncompletePattern", "regexContext", "charClassContext", "interpolated", "interpolate", "postp", "transformAtomicGroups", "rakeSeparators", "p", "value", "RegexContext", "CharClassContext", "isPartial", "PartialPattern", "escapedValue", "escapeV", "breakoutChar", "getBreakoutChar", "replaceUnescaped", "sandboxedValue", "sandboxLoneCharClassCaret", "sandboxLoneDoublePunctuatorChar", "containsCharClassUnion", "transformed", "transformForLocalFlags", "backrefsAdjusted", "adjustNumberedBackrefs", "re", "outerFlags", "modFlagsObj", "newlines", "patternModsOn", "keys", "modifier", "k", "modOff", "rregex", "first", "values", "postprocessors", "recursion", "tag", "regex", "pattern", "groupContentsStartPos", "numCharClassesOpen", "match", "token", "m", "capturingGroupName", "rDepth", "gRName", "gRDepth", "maxDepth", "assertMaxInBounds", "pre", "post", "assertNoFollowingRecursion", "makeRecursive", "outsideOwnGroupMsg", "recursiveGroupContents", "getContentsOfGroup", "hasUnescaped", "gRToken", "Context", "recursiveToken", "max", "remainingPattern", "contentsStartPos", "contentsEndPos", "numGroupsOpen", "groupStart", "reps", "repeatWithDepth", "direction", "depthNum", "i", "result", "captureNum", "replaceUnescaped", "captureName", "backref", "suffix"]
}
