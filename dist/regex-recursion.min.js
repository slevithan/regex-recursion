var Regex;(Regex||={}).ext=(()=>{var C=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var se=Object.prototype.hasOwnProperty;var ie=(e,t)=>{for(var r in t)C(e,r,{get:t[r],enumerable:!0})},ae=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of oe(t))!se.call(e,o)&&o!==r&&C(e,o,{get:()=>t[o],enumerable:!(n=ne(t,o))||n.enumerable});return e};var ce=e=>ae(C({},"__esModule",{value:!0}),e);var Ae={};ie(Ae,{recursion:()=>X,rregex:()=>ge});var g={DEFAULT:"DEFAULT",CHAR_CLASS:"CHAR_CLASS"};function A(e,t,r,n){let o=new RegExp(String.raw`(?<found>${t})|\\?.`,"gsu"),c=0,s="";for(let i of e.matchAll(o)){let{0:l,groups:{found:u}}=i;if(u&&(!n||n===g.DEFAULT==!c)){r instanceof Function?s+=r(i):s+=r;continue}l==="["?c++:l==="]"&&c&&c--,s+=l}return s}function le(e,t,r,n){if(!new RegExp(t,"su").test(e))return!1;let o=new RegExp(String.raw`(?<found>${t})|\\?.`,"gsu"),c=0;for(let s of e.matchAll(o)){let{0:i,groups:{found:l}}=s;if(l&&(!n||n===g.DEFAULT==!c))return r&&r(s),!0;i==="["?c++:i==="]"&&c&&c--}return!1}function _(e,t,r){return le(e,t,null,r)}function G(e){if(!_(e,String.raw`\(\?>`,g.DEFAULT))return e;let t=new RegExp(String.raw`(?<noncapturingStart>\(\?(?:[:=!>A-Za-z\-]|<[=!]))|(?<capturingStart>\((?:\?<[^>]+>)?)|(?<backrefNum>\\[1-9]\d*)|\\?.`,"gsu"),r=3,n,o=0,c=0,s=NaN;do{n=!1;let i=0,l=0,u=!1,E;for(t.lastIndex=Number.isNaN(s)?0:s+r;E=t.exec(e);){let{0:a,index:m,groups:{backrefNum:d,capturingStart:T,noncapturingStart:$}}=E;if(a==="[")i++;else if(i)a==="]"&&i--;else if(a==="(?>"&&!u)s=m,u=!0;else if(u&&$)l++;else if(T)u&&l++,o++;else if(a===")"&&u){if(!l){c++,e=`${e.slice(0,s)}(?:(?=(${e.slice(s+r,m)}))\\k<${c+o}>)${e.slice(m+1)}`,n=!0,o--;break}l--}else if(d)throw new Error(`Invalid decimal escape "${a}" in interpolated regex; cannot be used with atomic group`)}}while(n);return e=A(e,String.raw`\\k<(?<backrefNum>\d+)>`,({groups:{backrefNum:i}})=>`\\${i}`,g.DEFAULT),e}var N=class{#e;constructor(t){this.#e=t}toString(){return String(this.#e)}};function U(e,...t){if(Array.isArray(e?.raw))return new N(e.raw.flatMap((r,n)=>n<e.raw.length-1?[r,t[n]]:r).join(""));if(!t.length)return new N(e??"");throw new Error(`Unexpected arguments: ${JSON.stringify([e,...t])}`)}var f={...g,GROUP_NAME:"GROUP_NAME",ENCLOSED_TOKEN:"ENCLOSED_TOKEN",INTERVAL_QUANTIFIER:"INTERVAL_QUANTIFIER",INVALID_INCOMPLETE_TOKEN:"INVALID_INCOMPLETE_TOKEN"},p={DEFAULT:"CC_DEFAULT",RANGE:"CC_RANGE",ENCLOSED_TOKEN:"CC_ENCLOSED_TOKEN",Q_TOKEN:"CC_Q_TOKEN",INVALID_INCOMPLETE_TOKEN:"CC_INVALID_INCOMPLETE_TOKEN"},O=(()=>{let e=!0;try{new RegExp("(?i-ms:)")}catch{e=!1}return e})(),D="&!#$%*+,.:;<=>?@^`~";function F(e,t){return t===f.CHAR_CLASS?e.replace(new RegExp(String.raw`[()\[\]{}|\\/\-${D}]`,"g"),"\\$&"):e.replace(/[()\[\]{}|\\^$*+?.]/g,"\\$&")}function S(e){return e.replace(new RegExp(String.raw`^([${D}])(?!\1)`),(t,r,n)=>`\\${t}${n+1===e.length?"":t}`)}function y(e){return e.replace(/^\^/,"\\^^")}function L(e,t){return A(e,String.raw`\\0(?!\d)`,"\\u{0}",t)}function M(e,t,r){let n=0;for(let[o]of e.matchAll(new RegExp(`[${F(t+r)}]`,"g")))if(n+=o===t?1:-1,n<0)return r;return n>0?t:""}function V(e,t,r){let n=e.replace(/\\./gsu,"");if(n.at(-1)==="\\")return"\\";if(t===f.DEFAULT)return M(n,"(",")");if(t===f.CHAR_CLASS&&!(r===p.ENCLOSED_TOKEN||r===p.Q_TOKEN))return M(n,"[","]");if(t===f.ENCLOSED_TOKEN||t===f.INTERVAL_QUANTIFIER||r===p.ENCLOSED_TOKEN||r===p.Q_TOKEN){if(n.includes("}"))return"}"}else if(t===f.GROUP_NAME&&n.includes(">"))return">";return""}var h=new RegExp(String.raw`
  (?<groupN> \(\?< (?! [=!] ) | \\k< )
| (?<enclosedT> \\[pPu]\{ )
| (?<qT> \\q\{ )
| (?<intervalQ> \{ )
| (?<incompleteT> \\ (?:
    $
  | c (?! [A-Za-z] )
  | u (?! [A-Fa-f\d]{4} ) [A-Fa-f\d]{0,3}
  | x (?! [A-Fa-f\d]{2} ) [A-Fa-f\d]?
  )
)
| \\ (?:
    c [A-Za-z]
  | u [A-Fa-f\d]{4}
  | x [A-Fa-f\d]{2}
  | 0 \d+
)
| \[\^
| \(\? [:=!<>A-Za-z\-]
| (?<dp> [${D}] ) \k<dp>
| \\[1-9]\d*
| --
| \\? .
`.replace(/\s+/g,""),"gsu");function w(e,{regexContext:t=f.DEFAULT,charClassContext:r=p.DEFAULT,charClassDepth:n=0,lastPos:o=0}){h.lastIndex=o;let c;for(;c=h.exec(e);){let{0:s,groups:{groupN:i,enclosedT:l,qT:u,intervalQ:E,incompleteT:a}}=c;s==="["||s==="[^"?(n++,t=f.CHAR_CLASS,r=p.DEFAULT):s==="]"&&t===f.CHAR_CLASS?(n&&n--,n||(t=f.DEFAULT),r=p.DEFAULT):t===f.CHAR_CLASS?a?r=p.INVALID_INCOMPLETE_TOKEN:s==="-"?r=p.RANGE:l?r=p.ENCLOSED_TOKEN:u?r=p.Q_TOKEN:(s==="}"&&(r===p.ENCLOSED_TOKEN||r===p.Q_TOKEN)||r===p.INVALID_INCOMPLETE_TOKEN||r===p.RANGE)&&(r=p.DEFAULT):a?t=f.INVALID_INCOMPLETE_TOKEN:i?t=f.GROUP_NAME:l?t=f.ENCLOSED_TOKEN:E?t=f.INTERVAL_QUANTIFIER:(s===">"&&t===f.GROUP_NAME||s==="}"&&(t===f.ENCLOSED_TOKEN||t===f.INTERVAL_QUANTIFIER)||t===f.INVALID_INCOMPLETE_TOKEN)&&(t=f.DEFAULT)}return{regexContext:t,charClassContext:r,charClassDepth:n,lastPos:e.length}}function x(e){let t=/(?<capture>\((?:(?!\?)|\?<[^>]+>))|\\?./gsu;return Array.from(e.matchAll(t)).filter(r=>r.groups.capture).length}function j(e,t){return e.replace(/\\([1-9]\d*)|\\?./gsu,(r,n)=>n?"\\"+(Number(n)+t):r)}var ue=["Basic_Emoji","Emoji_Keycap_Sequence","RGI_Emoji_Modifier_Sequence","RGI_Emoji_Flag_Sequence","RGI_Emoji_Tag_Sequence","RGI_Emoji_ZWJ_Sequence","RGI_Emoji"].join("|");function b(e){let t=new RegExp(String.raw`
\\ (?:
    c [A-Za-z]
  | p \{ (?<pPropOfStr> ${ue} ) \}
  | [pP] \{ [^\}]+ \}
  | (?<qPropOfStr> q )
  | u (?: [A-Fa-f\d]{4} | \{ [A-Fa-f\d]+ \} )
  | x [A-Fa-f\d]{2}
  | .
)
| --
| &&
| .
  `.replace(/\s+/g,""),"gsu"),r=!1,n;for(let{0:o,groups:c}of e.matchAll(t)){if(c.pPropOfStr||c.qPropOfStr||o==="["&&r)return!0;if(["-","--","&&"].includes(o))r=!1;else if(!["[","]"].includes(o)){if(r||n==="]")return!0;r=!0}n=o}return!1}function P(e,t,r){let n={raw:[]},o=[],c={};return e.raw.forEach((s,i)=>{let l=r(s,{...c,lastPos:0});if(n.raw.push(l.transformed),c=l.runningContext,i<e.raw.length-1){let u=t[i];if(u instanceof N){let E=r(u,{...c,lastPos:0});o.push(U(E.transformed)),c=E.runningContext}else o.push(u)}}),{template:n,values:o}}function Q(e,t){e=String(e);let r="",n="";for(let[o]of e.matchAll(h)){r+=o,t=w(r,t);let{regexContext:c}=t;if(c===f.DEFAULT)if(o==="(")n+="(?:";else{if(/^\\[1-9]/.test(o))throw new Error(`Invalid decimal escape "${o}" with implicit flag n; replace with named backreference`);n+=o}else n+=o}return{transformed:n,runningContext:t}}var H=/^\s$/,fe=/^\\[\s#]$/,q=/^[ \t]$/,pe=/^\\[ \t]$/;function W(e,t){e=String(e);let r=!1,n=!1,o=!1,c="",s="",i="",l="",u=!1,E=(a,{prefix:m=!0,postfix:d=!1}={})=>(a=(u&&m?"(?:)":"")+a+(d?"(?:)":""),u=!1,a);for(let[a]of e.matchAll(h)){if(o){a===`
`&&(o=!1,u=!0);continue}if(r){if(H.test(a))continue;r=!1,u=!0}else if(n){if(q.test(a))continue;n=!1}c+=a,t=w(c,t);let{regexContext:m,charClassContext:d}=t;if(a==="-"&&m===f.CHAR_CLASS&&l===p.RANGE)throw new Error("Invalid unescaped hyphen as the end value for a range");if(m===f.DEFAULT&&/^[?*+]\??$/.test(a)||m===f.INTERVAL_QUANTIFIER&&a==="{")s+=E(a,{prefix:!1,postfix:i==="("});else if(m===f.DEFAULT)H.test(a)?r=!0:a.startsWith("#")?o=!0:fe.test(a)?s+=E(a[1],{prefix:!1}):s+=E(a);else if(m===f.CHAR_CLASS&&a!=="["&&a!=="[^")if(q.test(a)&&(d===p.DEFAULT||d===p.RANGE||d===p.Q_TOKEN))n=!0;else{if(d===p.INVALID_INCOMPLETE_TOKEN)throw new Error(`Invalid incomplete token in character class: "${a}"`);pe.test(a)&&(d===p.DEFAULT||d===p.Q_TOKEN)?s+=E(a[1],{prefix:!1}):d===p.DEFAULT?s+=E(S(L(a))):s+=E(a)}else s+=E(a);r||n||o||(i=a,l=d)}return{transformed:s,runningContext:t}}function v(e){let t=String.raw`\(\?:\)`;return e=A(e,`${t}(?:${t})+`,"(?:)",g.DEFAULT),e=A(e,String.raw`^${t}(?![?*+{])|${t}$|${t}(?=[()|$\\])|(?<=[()|>^]|\(\?(?:[:=!]|<[=!]))${t}`,"",g.DEFAULT),e}var I=function(e,...t){let r=this instanceof Function?this:RegExp;if(Array.isArray(e?.raw))return k(r,{flags:""},e,...t);if((typeof e=="string"||e===void 0)&&!t.length)return k.bind(null,r,{flags:e});if({}.toString.call(e)==="[object Object]"&&!t.length)return k.bind(null,r,e);throw new Error(`Unexpected arguments: ${JSON.stringify([e,...t])}`)};function k(e,t,r,...n){let{flags:o="",postprocessors:c=[],__flagN:s=!0,__flagX:i=!0,__rake:l=!0}=t;if(/[vu]/.test(o))throw new Error("Flags v/u cannot be explicitly added since v is always enabled");i&&({template:r,values:n}=P(r,n,W)),s&&({template:r,values:n}=P(r,n,Q));let u=0,E="",a={};r.raw.forEach((d,T)=>{let $=r.raw[T]||r.raw[T+1];u+=x(d),E+=L(d,g.CHAR_CLASS),a=w(E,a);let{regexContext:te,charClassContext:re}=a;if(T<r.raw.length-1){let K=Ee(n[T],o,te,re,$,u);u+=K.capturesAdded||0,E+=K.value}});let m=[G,...c];l&&m.push(v);for(let d of m)E=d(E);return new e(E,`v${o}`)}function Ee(e,t,r,n,o,c){if(e instanceof RegExp&&r!==f.DEFAULT)throw new Error("Cannot interpolate a RegExp at this position because the syntax context does not match");if(r===f.INVALID_INCOMPLETE_TOKEN||n===p.INVALID_INCOMPLETE_TOKEN)throw new Error("Interpolation preceded by invalid incomplete token");let s=e instanceof N,i;if(!(e instanceof RegExp)){e=String(e),s||(i=F(e,r));let l=V(i||e,r,n);if(l)throw new Error(`Unescaped stray "${l}" in the interpolated value would have side effects outside it`)}if(r===f.ENCLOSED_TOKEN||r===f.INTERVAL_QUANTIFIER||r===f.GROUP_NAME||n===p.ENCLOSED_TOKEN||n===p.Q_TOKEN)return{value:s?e:i};if(r===f.CHAR_CLASS){if(s){if(A(e,"^-|^&&|-$|&&$","")!==e)throw new Error("In character classes, a partial cannot use a range/set operator at its boundary; move the operation into the partial or the operator outside of it");let u=y(S(e));return{value:b(e)?`[${u}]`:L(u)}}return{value:b(i)?`[${i}]`:i}}if(e instanceof RegExp){let l=de(e,t),u=j(l.value,c);return{value:l.usedModifier?u:`(?:${u})`,capturesAdded:x(e.source)}}return s?{value:`(?:${e})`}:{value:o?`(?:${i})`:i}}function de(e,t){let r={i:null,m:null,s:null},n="\\n\\r\\u2028\\u2029",o=e.source;if(e.ignoreCase!==t.includes("i"))if(O)r.i=e.ignoreCase;else throw new Error("Pattern modifiers not supported, so the value of flag i on the interpolated RegExp must match the outer regex");if(e.dotAll!==t.includes("s")&&(O?r.s=e.dotAll:o=A(o,"\\.",e.dotAll?"[^]":`[^${n}]`,g.DEFAULT)),e.multiline!==t.includes("m")&&(O?r.m=e.multiline:(o=A(o,"\\^",e.multiline?`(?<=^|[${n}])`:"(?<![^])",g.DEFAULT),o=A(o,"\\$",e.multiline?`(?=$|[${n}])`:"(?![^])",g.DEFAULT))),O){let c=Object.keys(r),s=c.filter(l=>r[l]===!0).join(""),i=c.filter(l=>r[l]===!1).join("");if(i&&(s+=`-${i}`),s)return{value:`(?${s}:${o})`,usedModifier:!0}}return{value:o}}function ge(e,...t){let r=(e?.postprocessors||[]).concat(X),n=this instanceof Function?this:RegExp;if(Array.isArray(e?.raw))return I.bind(n)({flags:"",postprocessors:r})(e,...t);if((typeof e=="string"||e===void 0)&&!t.length)return I.bind(n)({flags:e,postprocessors:r});if({}.toString.call(e)==="[object Object]"&&!t.length)return I.bind(n)({...e,postprocessors:r});throw new Error(`Unexpected arguments: ${JSON.stringify([e,...t])}`)}function X(e){let t={},r=0,n;for(R.lastIndex=0;n=R.exec(e);){let{0:o,groups:{capGroupName:c,rDepth:s,gRName:i,gRDepth:l}}=n;if(o==="[")r++;else if(r)o==="]"&&r--;else if(c)t[c]=R.lastIndex;else if(s){let u=+s;Z(u);let E=e.slice(0,n.index),a=e.slice(R.lastIndex);return z(a),B(E,a,u)}else if(i){let u=+l;Z(u);let E=`Recursion via \\g<${i}> must be within the referenced group`;if(!Object.hasOwn(t,i))throw new Error(E);let a=me(e,t[i]);if(!_(a,Y,g.DEFAULT))throw new Error(E);let m=e.slice(t[i],n.index),d=a.slice(m.length+o.length);return z(d),e.slice(0,t[i])+B(m,d,u)+e.slice(t[i]+a.length)}}return e}var Y=String.raw`\\g<(?<gRName>[^>&]+)&R=(?<gRDepth>\d+)>`,ee=String.raw`\(\?R=(?<rDepth>\d+)\)|${Y}`,R=new RegExp(String.raw`\(\?<(?![=!])(?<capGroupName>[^>]+)>|${ee}|\\?.`,"gsu");function Z(e){if(e<2||e>100)throw new Error(`Max depth must be between 2 and 100; used ${e}`)}function z(e){if(_(e,ee,g.DEFAULT))throw new Error("Cannot use recursion more than once in a pattern")}function me(e,t){let r=/(?<groupStart>\(\?[:=!<>A-Za-z\-])|\\?./gsu;r.lastIndex=t;let n=e.length,o=0,c=1,s;for(;s=r.exec(e);){let{0:i,groups:{groupStart:l}}=s;if(i==="[")o++;else if(o)i==="]"&&o--;else if(l)c++;else if(i===")"&&(c--,!c)){n=s.index;break}}return e.slice(t,n)}function B(e,t,r){let n=r-1;return`${e}${J(`(?:${e}`,n)}(?:)${J(`${t})`,n,"backward")}${t}`}function J(e,t,r="forward"){let o=s=>r==="backward"?t-s+2-1:s+2,c="";for(let s=0;s<t;s++){let i=o(s);c+=A(e,String.raw`\(\?<(?<captureName>[^>]+)>|\\k<(?<backref>[^>]+)>`,({groups:{captureName:l,backref:u}})=>l?`(?<${l}$r${i}>`:`\\k<${u}$r${i}>`,g.DEFAULT)}return c}return ce(Ae);})();
/*! Bundled license information:

regex/src/index.js:
  (*! regex 1.1.1; Steven Levithan; MIT License *)
*/
//# sourceMappingURL=regex-recursion.min.js.map
